
# -*- coding: utf-8 -*-
import threading

class ThreadPlay(object):
    """
    多任务可以由多进程完成，也可以由一个进程内的多线程完成。

    1- Python的线程是真正的Posix Thread，而不是模拟出来的线程!
    2- python内置了多线程的支持，_thread是低级模块，threading对前者封装的高级模块!
    3- 一个线程就是一个轻量级进程，Python是如何运行多线程的，GIL 是如何贯穿线程的 ?
    4- 守护进程 / 守护线程 （daemon），print是线程不安全的 ？

    GIL （global interpreter lock）       【单词： Interceptor 拦截器】
        线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，
        程序自己不能决定什么时候执行，执行多长时间。

    1- java实现的是一种多线程的机制，就java本身概念而言(虚拟机规范)，它是进程级别的。
    2- 但是java到底是多进程的还是多线程的，根本由操作系统本身来决定，并不由java来决定，
       因为进程与线程的这种机制本身就只取决于操作系统，而不取决于高级语言。
    3- 对于内存分配以及cpu时间片段的分配利用，是由更低级的比操作系统低的语言来实现。
    4- 对于一些老式的unix操作系统，它是没有线程概念存在的，它的异步协作方式就是多进程共享内存的方式来完成的，
       因此，在这种操作系统上，根本就不存在线程，java也没法实现线程，因此java就是多进程的应用程序，由多个java进程来完成协作。
    5- 在windows上面，进程间的内存空间是互相独立的，数据不能直接共享，它的异步协作方式由进程中的线程来完成，
       这些线程共享进程所属内存来完成异步协作，所以java在这种操作系统上，表现的就是单进程多线程的方式。
    6- 就进程与线程的概念，并不是java本身一个概念，它们是操作系统级别的概念，java只是将操作系统的这种方式进行了包装，
       而并非自己去实现一套cpu时钟与内存访问机制，java本身是跳不出操作系统层面的。
    7- 多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享。

    TODO 在线程退出后，尝试再次启动线程时，抛出RuntimeError异常，表明线程对象在定义后只能启动一次。
    """

    # 锁阻止了多线程并发执行，锁会让代码块只能被单线程模式执行，效率就大大地下降了。
    # 由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，
    # 导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。

    '''
    在多核 CPU上 启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。
    但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？
    Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，
    任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。
    这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。
    GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。
    所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。
    Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。
    '''

    # ThreadLocal 对象 维护一个Map，在一个线程执行流内共享变量，ThreadLocal访问是线程安全的。
    kvs = threading.local()
    def __init__(self):
        lock = threading.Lock()
        lock.acquire()
        try:
            2/0
            print(threading.current_thread()) # 进程中的主线程
        except Exception:
            lock.release

    # 实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker

class CBThread(threading.Thread):

    def run():
        pass

"""
    多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，
    但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。

    多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。
    另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。

    多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，
    因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，
    即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。

    在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。
    为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。

    如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，
    点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。

    是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。

    计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，
    但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
    计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。

    IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。
    对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。
    IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，
    完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。
"""

"""
    考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，
    单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。

    现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。
    如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，
    这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。
    在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。
    由于系统总的进程数量十分有限，因此操作系统调度非常高效。
    用异步IO编程模型来实现多任务是一个主要的趋势。TODO select poll epoll

    对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序
 """